use std::{
    env,
    fs::{File, read_to_string},
    io::{Write},
};

fn interpret_command(command: char, tabs: usize) -> String {
    let mut output_code = String::from("\n");
    for _ in 0..tabs {
        output_code.push('\t');
    }
    match command {
        '+' => {
            output_code.push_str(
                "if cells[current_cell] < 255 {{cells[current_cell] += 1;}} else {{cells[current_cell] = 0;}}"
            );
        }

        '-' => {
            output_code.push_str(
                "if cells[current_cell] > 0 {{cells[current_cell] -= 1;}} else {{cells[current_cell] = 255;}}"
            );
        }

        '>' => {
            output_code.push_str(
                "if current_cell < 29999 {{current_cell += 1;}} else {{current_cell = 0;}}",
            );
        }

        '<' => {
            output_code.push_str(
                "if current_cell > 0 {{current_cell -= 1;}} else {{current_cell = 29999;}}",
            );
        }

        ',' => {
            output_code.push_str(
                "let _ = std::io::stdout().flush();\n"
            );
            for _ in 0..tabs {
                output_code.push('\t');
            }
            output_code.push_str("cells[current_cell] = std::io::stdin().bytes().next().unwrap().unwrap();");
        }

        '.' => {
            output_code.push_str(
                "std::io::stdout().write(&[cells[current_cell]]).unwrap();"
            );
        }

        _ => {}
    }
    output_code
}

fn interpret(code: String) -> String {
    let mut output_code: String = String::from("// Generated by bf2rs\nuse std::io::{{Read, Write}};\n\nfn main() {\n\tlet mut cells = vec![0_u8; 30000];\n\tlet mut current_cell: usize = 15000;\n\tlet mut c: u8 = 0;\n");
    let mut is_in_loop: bool = false;
    let mut loop_code: String = String::from("");
    let tabs: usize = 1;

    for command in code.chars() {
        match command {
            '[' => {
                is_in_loop = true;
            }

            ']' => {
                is_in_loop = false;
                let mut tabs_to_add = String::new();
                for _ in 0..tabs {
                    tabs_to_add.push('\t');
                }
                output_code.push_str(
                    format!(
                        "\n{}while cells[current_cell] != 0 {{\n",
                        tabs_to_add
                    ).as_str()
                );
                tabs_to_add.push('\t');
                for c in loop_code.chars() {
                    output_code.push_str(interpret_command(c, tabs + 1).as_str());
                }
                output_code.push_str(
                    format!(
                        "\n{}}}",
                        &tabs_to_add[1..tabs_to_add.len() - 1]
                    ).as_str()
                );
                loop_code = String::from("");
            }

            other => {
                if is_in_loop {
                    loop_code.push(other);
                } else {
                    output_code.push_str(interpret_command(other, tabs).as_str());
                }
            }
        }
    }
    output_code.push_str("\n}\n");
    output_code
}

fn main() {
    let args: Vec<String> = env::args().skip(1).collect();

    if args.len() != 1 {
        println!("Usage: {} <file>", args[0]);
        return;
    }

    let input_file_path = args[0].clone();

    match read_to_string(input_file_path.clone()) {
        Ok(code) => {
            let mut output_file_path = input_file_path;
            if output_file_path.contains('.') {
                output_file_path = output_file_path.split('.').collect::<Vec<&str>>()[0].to_owned() + ".rs";
            } else {
                output_file_path.push_str(".rs");
            }

            let output_code = interpret(code);

            match File::create(output_file_path.clone()) {
                Ok(mut output_file) => {
                    match output_file.write_all(output_code.as_bytes()) {
                        Ok(_) => println!("Success!\nOutput file: {}", output_file_path),
                        Err(e) => println!("Error writing {}: {}", output_file_path, e),
                    }
                }

                Err(e) => println!("Error creating {}: {}", output_file_path, e),
            }
        }

        Err(e) => {
            println!("Could not read file `{}`: {}", input_file_path, e);
        }
    }
}